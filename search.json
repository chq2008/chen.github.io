[{"title":"3种方法实现一个基于Go语言的Web服务器","url":"http://yoursite.com/2019/07/15/go-http/","content":"<blockquote>\n<p>go语言中的http库是一个非常简单、实用的底层封装库，几行代码就可以实现一个Web服务器。(本文基于Go版本1.12.4)</p>\n</blockquote>\n<h2 id=\"第一种实现\"><a href=\"#第一种实现\" class=\"headerlink\" title=\"第一种实现\"></a>第一种实现</h2><p>首先上代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">\"/\"</span>, handler)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">\"localhost:8000\"</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"URL.Path = %q\\n\"</span>, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单的十来行代码，我们来看看发生了什么吧。首先是HandlerFunc方法的参数要求。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">\tDefaultServeMux.HandleFunc(pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码中可以看出，是注册了一个handle函数给pattern路由路径，handler函数接受两个参数，1是ResponseWriter的值传递，2是Request的指针传递，再跳转Request中发现Request是一个结构体，实例化之后默认是值传递，所以为了节省内存将它设置为指针传递，而ResponseWriter是个接口，并不存在指针传递。</p>\n<p>知道handler的参数那么接下来实现的handler就很简单了。注册好路由需要通过ListenAndServe来启动服务，它接受两个参数，1是服务器的地址，2是接口的实例，上面例子由于我们使用的是默认的serve mux，所以传递一个nil就可以了。</p>\n<p>流程是“/”路由路径和处理函数绑定在一起  –&gt;  启动服务器监听服务器地址  –&gt;  访问“/”路径时，请求到达转交给处理函数  –&gt;  处理函数从请求的URL提取Path，然后用fmt格式化并作为响应发送出去。</p>\n<p>可能这还不够底层，接下来看第二版本。</p>\n<h2 id=\"第二种实现\"><a href=\"#第二种实现\" class=\"headerlink\" title=\"第二种实现\"></a>第二种实现</h2><p>第一个例子中并没有完全控制处理函数handler，而是使用了程序中init()初始化中的默认serve mux。接下来自己实现一个mux。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    mux := http.NewServeMux()</span><br><span class=\"line\"></span><br><span class=\"line\">    mux.Handle(<span class=\"string\">\"/\"</span>, &amp;myHandler&#123;&#125;)</span><br><span class=\"line\">    mux.HandleFunc(<span class=\"string\">\"/hello\"</span>, handler)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">\"localhost:8000\"</span>, mux))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> myHandler <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*myHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"URL:\"</span> + r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"hello, world!\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义的mux，而不是使用系统自带的DefaultServeMux，这样的好处是可以在服务中完全控制handler。而handler也可以自定义，前提是需要实现一个ServeHTTP方法。</p>\n<h2 id=\"第三种实现\"><a href=\"#第三种实现\" class=\"headerlink\" title=\"第三种实现\"></a>第三种实现</h2><p>接下来看ListenAndServe的源码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>里面封装了一个Server的结构，然后进行监听，那么由我们自己来实现这个Server</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">    <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mux <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(http.ResponseWriter, *http.Request)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    server := http.Server&#123;</span><br><span class=\"line\">        Addr:   <span class=\"string\">\"localhost:8000\"</span>,</span><br><span class=\"line\">        Handler:  &amp;myHandler&#123;&#125;,</span><br><span class=\"line\">        ReadTimeout:  <span class=\"number\">5</span>*time.Second,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mux = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(http.ResponseWriter, *http.Request)</span>)</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">mux</span>[\"/<span class=\"title\">hello</span>\"] = <span class=\"title\">hello</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">mux</span>[\"/<span class=\"title\">bye</span>\"] = <span class=\"title\">bye</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">log</span>.<span class=\"title\">Fatal</span><span class=\"params\">(server.ListenAndServe()</span>)</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">type</span> <span class=\"title\">myHandler</span> <span class=\"title\">struct</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*myHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h, ok := mux[r.URL.Path]; ok &#123;</span><br><span class=\"line\">        h(w, r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"hello, world!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bye</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"bye!\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于Server结构体中并没有和路径相关的成员，那么我们如何实现路径绑定呢，此时可以利用go中的数据结构map，由路径字符串作为key，handler函数作为值形成一个映射关系，而我们在handler中的唯一一个ServeHTTP方法中来进行路由转发，从map中判断路径是否存在，即可实现绑定相应的handler。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><p>ServeHTTP方法是可以基于URL路径来决定执行哪部分逻辑，但是现实中的应用往往会有一大堆逻辑，我们需要分离到独立的函数及方法中。</p>\n</li>\n<li><p>为了简化URL和处理函数之间的关联，net/http包中提供一个<em>多工转发器</em>ServeMux，将多个Handle组合成单个Handle。</p>\n</li>\n<li><p>更复杂的应用中，ServeMux会组合起来。</p>\n</li>\n<li><p>注册处理程序的方法太常见来，所以ServeMux引用了一个HandleFunc的便捷方法来处理。</p>\n</li>\n<li><p>对于绝大多数服务来说，一个Web服务远远足够，这个服务可能会在很多文件中定义处理程序，但是每次都要注册到ServeMux中，太麻烦了，所以net/http包提供了一个全局的ServeMux实例DefaultServeMux，使DefaultServeMux作为服务器的主处理程序，这样就无须将它传给ListenAndServe，直接传nil即可。</p>\n</li>\n</ol>\n","categories":["技术"],"tags":["Goland","Web","服务器"]},{"title":"第一次使用hexo","url":"http://yoursite.com/2019/06/27/start-hexo/","content":"<blockquote>\n<p>花了一天时间开了个hexo的静态博客，比起自己从零搭建一个博客好处就是太方便了。主题使用的是<a href=\"https://github.com/forsigner/fexo\" target=\"_blank\" rel=\"noopener\">fexo</a>,是个极简风格的，第一眼看到就中意上了。博客头像是今年寒假在日本旅行遇到的2019年的第一场雪，当时深夜在街道上站了好久拍的一张图，冻的瑟瑟发抖，没想到这一冻就是一年。</p>\n</blockquote>\n<h2 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h2><p>整个搭建下来还是蛮容易的，fexo提供的文档非常清晰。</p>\n<p>先把<a href=\"https://github.com/forsigner/fexo\" target=\"_blank\" rel=\"noopener\">fexo</a>克隆到themes文件夹中，在_config.yml配置文件中修改主题为fexo。</p>\n<p>接下来的配置在themes/fexo/_config.yml中进行，文档都有说明。</p>\n<h3 id=\"1-hexo命令\"><a href=\"#1-hexo命令\" class=\"headerlink\" title=\"1. hexo命令\"></a>1. hexo命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g  // 执行生成静态文件</span><br><span class=\"line\">hexo d  // 部署</span><br><span class=\"line\">hexo s --debug  // 本地debug</span><br><span class=\"line\">hexo clean  // 清除缓存</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new [layout] &lt;title&gt; // layout默认为post，创建一篇文章</span><br></pre></td></tr></table></figure>\n\n<p>经常用到的也就是上面一些命令，更多的也都能在hexo文档里面找到。</p>\n<h2 id=\"使用到的配置\"><a href=\"#使用到的配置\" class=\"headerlink\" title=\"使用到的配置\"></a>使用到的配置</h2><p>fexo本身自带了很多有用的配置，只需要在themes/fexo/_config.yml中填写相应的参数即可。</p>\n<h3 id=\"1-打赏二维码\"><a href=\"#1-打赏二维码\" class=\"headerlink\" title=\"1. 打赏二维码\"></a>1. 打赏二维码</h3><p>随着知识付费的理念越来越普及，很多博主都会在博文下方添加一个收钱二维码，大致意思是创作不易，请杯咖啡。</p>\n<p>笔者也厚着脸皮跟风添加了一个，将图片放置themes/fexo/source/images中，然后在配置文件中填入相应的路径即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- type: 微信</span><br><span class=\"line\">text: 微信扫一扫</span><br><span class=\"line\">imgUrl: /images/xxx.png   // 二维码图片名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-谷歌、百度分析\"><a href=\"#2-谷歌、百度分析\" class=\"headerlink\" title=\"2. 谷歌、百度分析\"></a>2. 谷歌、百度分析</h3><p>两款用来分析网站流量的工具。</p>\n<p><a href=\"https://analytics.google.com/analytics/web/\" target=\"_blank\" rel=\"noopener\">谷歌分析</a>需要翻墙</p>\n<p><a href=\"https://tongji.baidu.com/web/welcome/login\" target=\"_blank\" rel=\"noopener\">百度分析</a>需要注册，ps:百度账号不能使用。</p>\n<p>两者随便选择一种即可，然后将获取到的key值添加到配置文件中即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">google_analytics: xxxxxxxxx</span><br><span class=\"line\">baidu_analytics: xxxxxxxxx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-评论\"><a href=\"#3-评论\" class=\"headerlink\" title=\"3. 评论\"></a>3. 评论</h3><p>使用<a href=\"https://github.com/gitalk/gitalk\" target=\"_blank\" rel=\"noopener\">gitalk</a>的评论服务，需要先在github仓库下建立一个OAuth Application。然后将获取到的Client ID和Client Secret填入配置文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitalk:</span><br><span class=\"line\">enable: true # 如果使用 gitalk，请设置改之为true</span><br><span class=\"line\">clientID: xxx</span><br><span class=\"line\">clientSecret: xxx</span><br><span class=\"line\">repo:   // 仓库名</span><br><span class=\"line\">owner:  // github用户名</span><br><span class=\"line\">admin:   // 同上</span><br></pre></td></tr></table></figure>\n\n<p>其中遇到了一个坑就是，配置好在文章下出现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">未找到相关的Issues进行评论</span><br><span class=\"line\">请联系@xxx 初始化创建</span><br><span class=\"line\">使用github登录</span><br></pre></td></tr></table></figure>\n\n<p>点击登录之后，就会跳转重定向到首页，原因是OAuth Apps配置中填入的Authorization callback URL和Homepage URL都带了www,和页面的连接不一样，所以导致重定向失败。</p>\n<p>遇到这种情况先打开开发者工具中network选项，然后详细看发送的网络请求，就能定位出错误的所在了。</p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>搭建博客的原因，居然是我Python1年经验，在帝都获得不到一次面试机会！很后悔自己没有写博客的习惯，而是依赖于网易云笔记。</p>\n<p>但是为了找工作而搭建这个博客明显是非常功利的，希望自己能坚持下去把。</p>\n<p>并且早日找到满意的工作，在这寒风凛冽的冬天中。</p>\n<p>2019/6/27</p>\n","categories":["技术"],"tags":["hexo","技术博客","markdown"]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]}]