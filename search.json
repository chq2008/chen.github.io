[{"title":"React新特性Hooks","url":"http://yoursite.com/2019/08/04/hooks-1/","content":"<blockquote>\n<p>最近由于某些机缘巧合的原因在写前端，由于项目被React重构，而且用的还是最新的React技术Hooks，由于之前只简单了解过React，趁着这次机会系统的学习一下Hooks，强化一下前端的知识。</p>\n</blockquote>\n<h2 id=\"Hooks是什么\"><a href=\"#Hooks是什么\" class=\"headerlink\" title=\"Hooks是什么\"></a>Hooks是什么</h2><p>hooks是React16.8的新特性，是去年React团队推出的新特性，今年年初已经被稳定支持，可谓是非常时髦的一个知识点。hooks可以用函数组件来替换类组件，并且在函数组件中使用新方法来代替一系列的生命周期方法。</p>\n<h4 id=\"hooks优点\"><a href=\"#hooks优点\" class=\"headerlink\" title=\"hooks优点\"></a>hooks优点</h4><ul>\n<li>hooks完全可选，即想用就可以在自己项目中使用，不想用也不必须去学习，react没有废除class组件的想法，也就是说hooks并不是一门必学的课程。</li>\n<li>向后兼容，你可以在项目中一处使用，并不会导致你的项目整体不能使用，以前的语法和hooks并不冲突，你可以一点一点迁移到hooks上来。</li>\n</ul>\n<h4 id=\"hooks缺点\"><a href=\"#hooks缺点\" class=\"headerlink\" title=\"hooks缺点\"></a>hooks缺点</h4><ul>\n<li>并不能完全复现生命周期，hooks只不过将最常见的生命周期复现，但是还有一部分需要使用类组件来应用。</li>\n</ul>\n<h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><p>在react版本16.8及以上便可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h2><p>简单的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">10</span>);</span><br><span class=\"line\">onClick = &#123;() =&gt; setCount(count + <span class=\"number\">1</span>)&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>count是state</li>\n<li>setCount来更新state</li>\n<li>useState(10), 设置count默认值为10</li>\n</ol>\n<h2 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h2><p><code>useEffect</code>实现了<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>三种副作用。</p>\n<p>当组件被更新时，<code>useEffect</code>会在render之后被调用，如果想要当变量值变化就更新组件，只需在第二个参数传入一个数组即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.title = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span></span><br><span class=\"line\">&#125;, [count])</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二个参数不传，每次渲染后都执行。</li>\n<li>传一个空数组的话，只会执行一次。</li>\n</ul>\n<p>如果想要在组件被销毁前触发，需要加上回调函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此处相当于componentWillUnmount,来进行一些组件销毁时的操作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"useContext\"><a href=\"#useContext\" class=\"headerlink\" title=\"useContext\"></a>useContext</h2><p>Context在类组件中可以跨组件传递，避免一层一层传递，如果在hooks中使用context，用<code>useContext</code>即可，非常简单。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = useContext(xxxContext)</span><br></pre></td></tr></table></figure>\n\n<p>相比较类组件中的ContextType，函数组件可以使用多个<code>useContext</code>。</p>\n<h2 id=\"useMemo、useCallback\"><a href=\"#useMemo、useCallback\" class=\"headerlink\" title=\"useMemo、useCallback\"></a>useMemo、useCallback</h2><p>类组件中对指定组件渲染是用PureComponent，这样可以避免组件重复渲染，通过判断传入的属性值是否相等。</p>\n<p>在函数组件中，使用memo，见下例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Count = memo(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Count</span>(<span class=\"params\"></span>) =&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>useMemo</code>和memo相比，可以判断一段函数逻辑是否重复执行。<br>使用方法和memo相似</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = useMemo(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;, [])</span><br></pre></td></tr></table></figure>\n\n<p>其中第二个参数和<code>useEffect</code>使用逻辑一样，而与<code>useEffect</code>不同，<code>useEffect</code>在渲染之后运行，而<code>useMemo</code>在渲染期间完成。</p>\n<p>当<code>useMemo</code>返回的是函数，可以直接用<code>useCallback</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useCallback(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;, [])</span><br></pre></td></tr></table></figure>\n\n<p><code>useMemo(() =&gt; fn)</code> 等价于 <code>useCallback(fn)</code></p>\n<h2 id=\"useRef\"><a href=\"#useRef\" class=\"headerlink\" title=\"useRef\"></a>useRef</h2><p><code>useRef</code>使用有两种场景：</p>\n<ol>\n<li>获取字组件、DOM元素</li>\n<li>同步不同渲染周期需要共享的数据</li>\n</ol>\n<p>例如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> countRef = useRef();</span><br><span class=\"line\">&lt;Counter ref = &#123;countRef&#125; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.</span></span><br><span class=\"line\">count it = useRef();</span><br><span class=\"line\"><span class=\"comment\">// 赋值</span></span><br><span class=\"line\">it.current = <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">it.current</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hooks的规则\"><a href=\"#Hooks的规则\" class=\"headerlink\" title=\"Hooks的规则\"></a>Hooks的规则</h2><p>hooks有使用规则，我们必须按照规则严格使用，不然程序会出现各种各样的问题，还好这些规则十分简单。</p>\n<ol>\n<li>需要函数组件最顶层使用</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">functionName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// top-level顶层</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useCount(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>不允许在循环或者判断语句中使用</p>\n<p>很容易出现state值错乱的问题，就不要作死去尝试啦。</p>\n</li>\n<li><p>不能在类组件中使用</p>\n</li>\n<li><p>use是hooks关键所在</p>\n<p>当你定义一个函数开头使用use，那么就是一个hooks</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在学go中过程中，go就摒弃了类的实现，一开始也很不习惯，后来发现用的还舒心。react中的类组件因为逻辑状态复杂，难以理解，生命周期逻辑混乱，所以才诞生出hooks。</p>\n<p>虽然hooks还无法完全取代class，但hooks的诞生能应用在日常项目中的绝大多数环境下，取代使用最频繁的生命周期场景，使代码的可读性更强，用法更简便，已经足够了。</p>\n","categories":["技术"],"tags":["前端","React"]},{"title":"3种方法实现一个基于Go语言的Web服务器","url":"http://yoursite.com/2019/07/15/go-http/","content":"<blockquote>\n<p>go语言中的http库是一个非常简单、实用的底层封装库，几行代码就可以实现一个Web服务器。(本文基于Go版本1.12.4)</p>\n</blockquote>\n<h2 id=\"第一种实现\"><a href=\"#第一种实现\" class=\"headerlink\" title=\"第一种实现\"></a>第一种实现</h2><p>首先上代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">\"/\"</span>, handler)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">\"localhost:8000\"</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"URL.Path = %q\\n\"</span>, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单的十来行代码，我们来看看发生了什么吧。首先是HandlerFunc方法的参数要求。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">\tDefaultServeMux.HandleFunc(pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码中可以看出，是注册了一个handle函数给pattern路由路径，handler函数接受两个参数，1是ResponseWriter的值传递，2是Request的指针传递，再跳转Request中发现Request是一个结构体，实例化之后默认是值传递，所以为了节省内存将它设置为指针传递，而ResponseWriter是个接口，并不存在指针传递。</p>\n<p>知道handler的参数那么接下来实现的handler就很简单了。注册好路由需要通过ListenAndServe来启动服务，它接受两个参数，1是服务器的地址，2是接口的实例，上面例子由于我们使用的是默认的serve mux，所以传递一个nil就可以了。</p>\n<p>流程是“/”路由路径和处理函数绑定在一起  –&gt;  启动服务器监听服务器地址  –&gt;  访问“/”路径时，请求到达转交给处理函数  –&gt;  处理函数从请求的URL提取Path，然后用fmt格式化并作为响应发送出去。</p>\n<p>可能这还不够底层，接下来看第二版本。</p>\n<h2 id=\"第二种实现\"><a href=\"#第二种实现\" class=\"headerlink\" title=\"第二种实现\"></a>第二种实现</h2><p>第一个例子中并没有完全控制处理函数handler，而是使用了程序中init()初始化中的默认serve mux。接下来自己实现一个mux。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    mux := http.NewServeMux()</span><br><span class=\"line\"></span><br><span class=\"line\">    mux.Handle(<span class=\"string\">\"/\"</span>, &amp;myHandler&#123;&#125;)</span><br><span class=\"line\">    mux.HandleFunc(<span class=\"string\">\"/hello\"</span>, handler)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">\"localhost:8000\"</span>, mux))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> myHandler <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*myHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"URL:\"</span> + r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"hello, world!\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义的mux，而不是使用系统自带的DefaultServeMux，这样的好处是可以在服务中完全控制handler。而handler也可以自定义，前提是需要实现一个ServeHTTP方法。</p>\n<h2 id=\"第三种实现\"><a href=\"#第三种实现\" class=\"headerlink\" title=\"第三种实现\"></a>第三种实现</h2><p>接下来看ListenAndServe的源码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>里面封装了一个Server的结构，然后进行监听，那么由我们自己来实现这个Server</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">    <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mux <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(http.ResponseWriter, *http.Request)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    server := http.Server&#123;</span><br><span class=\"line\">        Addr:   <span class=\"string\">\"localhost:8000\"</span>,</span><br><span class=\"line\">        Handler:  &amp;myHandler&#123;&#125;,</span><br><span class=\"line\">        ReadTimeout:  <span class=\"number\">5</span>*time.Second,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mux = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(http.ResponseWriter, *http.Request)</span>)</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">mux</span>[\"/<span class=\"title\">hello</span>\"] = <span class=\"title\">hello</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">mux</span>[\"/<span class=\"title\">bye</span>\"] = <span class=\"title\">bye</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">log</span>.<span class=\"title\">Fatal</span><span class=\"params\">(server.ListenAndServe()</span>)</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">type</span> <span class=\"title\">myHandler</span> <span class=\"title\">struct</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*myHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h, ok := mux[r.URL.Path]; ok &#123;</span><br><span class=\"line\">        h(w, r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"hello, world!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bye</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"bye!\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于Server结构体中并没有和路径相关的成员，那么我们如何实现路径绑定呢，此时可以利用go中的数据结构map，由路径字符串作为key，handler函数作为值形成一个映射关系，而我们在handler中的唯一一个ServeHTTP方法中来进行路由转发，从map中判断路径是否存在，即可实现绑定相应的handler。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><p>ServeHTTP方法是可以基于URL路径来决定执行哪部分逻辑，但是现实中的应用往往会有一大堆逻辑，我们需要分离到独立的函数及方法中。</p>\n</li>\n<li><p>为了简化URL和处理函数之间的关联，net/http包中提供一个<em>多工转发器</em>ServeMux，将多个Handle组合成单个Handle。</p>\n</li>\n<li><p>更复杂的应用中，ServeMux会组合起来。</p>\n</li>\n<li><p>注册处理程序的方法太常见来，所以ServeMux引用了一个HandleFunc的便捷方法来处理。</p>\n</li>\n<li><p>对于绝大多数服务来说，一个Web服务远远足够，这个服务可能会在很多文件中定义处理程序，但是每次都要注册到ServeMux中，太麻烦了，所以net/http包提供了一个全局的ServeMux实例DefaultServeMux，使DefaultServeMux作为服务器的主处理程序，这样就无须将它传给ListenAndServe，直接传nil即可。</p>\n</li>\n</ol>\n","categories":["技术"],"tags":["Goland","Web","服务器"]},{"title":"第一次使用hexo","url":"http://yoursite.com/2019/06/27/start-hexo/","content":"<blockquote>\n<p>花了一天时间开了个hexo的静态博客，比起自己从零搭建一个博客好处就是太方便了。主题使用的是<a href=\"https://github.com/forsigner/fexo\" target=\"_blank\" rel=\"noopener\">fexo</a>,是个极简风格的，第一眼看到就中意上了。博客头像是今年寒假在日本旅行遇到的2019年的第一场雪，当时深夜在街道上站了好久拍的一张图，冻的瑟瑟发抖，没想到这一冻就是一年。</p>\n</blockquote>\n<h2 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h2><p>整个搭建下来还是蛮容易的，fexo提供的文档非常清晰。</p>\n<p>先把<a href=\"https://github.com/forsigner/fexo\" target=\"_blank\" rel=\"noopener\">fexo</a>克隆到themes文件夹中，在_config.yml配置文件中修改主题为fexo。</p>\n<p>接下来的配置在themes/fexo/_config.yml中进行，文档都有说明。</p>\n<h3 id=\"1-hexo命令\"><a href=\"#1-hexo命令\" class=\"headerlink\" title=\"1. hexo命令\"></a>1. hexo命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g  // 执行生成静态文件</span><br><span class=\"line\">hexo d  // 部署</span><br><span class=\"line\">hexo s --debug  // 本地debug</span><br><span class=\"line\">hexo clean  // 清除缓存</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new [layout] &lt;title&gt; // layout默认为post，创建一篇文章</span><br></pre></td></tr></table></figure>\n\n<p>经常用到的也就是上面一些命令，更多的也都能在hexo文档里面找到。</p>\n<h2 id=\"使用到的配置\"><a href=\"#使用到的配置\" class=\"headerlink\" title=\"使用到的配置\"></a>使用到的配置</h2><p>fexo本身自带了很多有用的配置，只需要在themes/fexo/_config.yml中填写相应的参数即可。</p>\n<h3 id=\"1-打赏二维码\"><a href=\"#1-打赏二维码\" class=\"headerlink\" title=\"1. 打赏二维码\"></a>1. 打赏二维码</h3><p>随着知识付费的理念越来越普及，很多博主都会在博文下方添加一个收钱二维码，大致意思是创作不易，请杯咖啡。</p>\n<p>笔者也厚着脸皮跟风添加了一个，将图片放置themes/fexo/source/images中，然后在配置文件中填入相应的路径即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- type: 微信</span><br><span class=\"line\">text: 微信扫一扫</span><br><span class=\"line\">imgUrl: /images/xxx.png   // 二维码图片名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-谷歌、百度分析\"><a href=\"#2-谷歌、百度分析\" class=\"headerlink\" title=\"2. 谷歌、百度分析\"></a>2. 谷歌、百度分析</h3><p>两款用来分析网站流量的工具。</p>\n<p><a href=\"https://analytics.google.com/analytics/web/\" target=\"_blank\" rel=\"noopener\">谷歌分析</a>需要翻墙</p>\n<p><a href=\"https://tongji.baidu.com/web/welcome/login\" target=\"_blank\" rel=\"noopener\">百度分析</a>需要注册，ps:百度账号不能使用。</p>\n<p>两者随便选择一种即可，然后将获取到的key值添加到配置文件中即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">google_analytics: xxxxxxxxx</span><br><span class=\"line\">baidu_analytics: xxxxxxxxx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-评论\"><a href=\"#3-评论\" class=\"headerlink\" title=\"3. 评论\"></a>3. 评论</h3><p>使用<a href=\"https://github.com/gitalk/gitalk\" target=\"_blank\" rel=\"noopener\">gitalk</a>的评论服务，需要先在github仓库下建立一个OAuth Application。然后将获取到的Client ID和Client Secret填入配置文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitalk:</span><br><span class=\"line\">enable: true # 如果使用 gitalk，请设置改之为true</span><br><span class=\"line\">clientID: xxx</span><br><span class=\"line\">clientSecret: xxx</span><br><span class=\"line\">repo:   // 仓库名</span><br><span class=\"line\">owner:  // github用户名</span><br><span class=\"line\">admin:   // 同上</span><br></pre></td></tr></table></figure>\n\n<p>其中遇到了一个坑就是，配置好在文章下出现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">未找到相关的Issues进行评论</span><br><span class=\"line\">请联系@xxx 初始化创建</span><br><span class=\"line\">使用github登录</span><br></pre></td></tr></table></figure>\n\n<p>点击登录之后，就会跳转重定向到首页，原因是OAuth Apps配置中填入的Authorization callback URL和Homepage URL都带了www,和页面的连接不一样，所以导致重定向失败。</p>\n<p>遇到这种情况先打开开发者工具中network选项，然后详细看发送的网络请求，就能定位出错误的所在了。</p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>搭建博客的原因，居然是我Python1年经验，在帝都获得不到一次面试机会！很后悔自己没有写博客的习惯，而是依赖于网易云笔记。</p>\n<p>但是为了找工作而搭建这个博客明显是非常功利的，希望自己能坚持下去把。</p>\n<p>并且早日找到满意的工作，在这寒风凛冽的冬天中。</p>\n<p>2019/6/27</p>\n","categories":["技术"],"tags":["hexo","技术博客","markdown"]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]}]